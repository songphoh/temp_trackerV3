// public/sw.js - Service Worker ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Mobile PWA

const CACHE_NAME = 'time-tracker-mobile-v1.2';
const STATIC_CACHE = 'static-v1.2';
const API_CACHE = 'api-v1.2';

// ‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á cache ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
const STATIC_RESOURCES = [
  '/',
  '/index.html',
  '/css/style.css',
  '/css/mobile-optimized.css',
  '/js/main.js',
  '/js/mobile-core.js',
  '/js/mobile-ui.js',
  '/js/mobile-app.js',
  '/js/performance-monitor.js',
  '/manifest.json',
  'https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css',
  'https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js'
];

// API endpoints ‡∏ó‡∏µ‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ cache ‡πÑ‡∏î‡πâ
const CACHEABLE_APIS = [
  '/api/mobile/employees',
  '/api/mobile/dashboard',
  '/api/getLiffId',
  '/api/getTimeOffset',
  '/api/getdata',
  '/api/getemployee'
];

// ‚≠ê Install Event - Cache static resources
self.addEventListener('install', event => {
  console.log('üì± Service Worker: Installing...');
  
  event.waitUntil(
    caches.open(STATIC_CACHE)
      .then(cache => {
        console.log('üì± Service Worker: Caching static resources');
        return cache.addAll(STATIC_RESOURCES);
      })
      .then(() => {
        console.log('üì± Service Worker: Installed successfully');
        return self.skipWaiting(); // ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
      })
      .catch(err => {
        console.error('üì± Service Worker: Install failed', err);
      })
  );
});

// ‚≠ê Activate Event - Clean old caches
self.addEventListener('activate', event => {
  console.log('üì± Service Worker: Activating...');
  
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            // ‡∏•‡∏ö cache ‡πÄ‡∏ß‡∏≠‡∏£‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏Å‡πà‡∏≤
            if (cacheName !== CACHE_NAME && 
                cacheName !== STATIC_CACHE && 
                cacheName !== API_CACHE) {
              console.log('üì± Service Worker: Deleting old cache', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => {
        console.log('üì± Service Worker: Activated successfully');
        return self.clients.claim(); // ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° clients ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
      })
  );
});

// ‚≠ê Fetch Event - Smart caching strategy
self.addEventListener('fetch', event => {
  const { request } = event;
  const url = new URL(request.url);
  
  // ‡∏Ç‡πâ‡∏≤‡∏° cross-origin requests
  if (url.origin !== location.origin) {
    return;
  }
  
  // ‡∏Ç‡πâ‡∏≤‡∏° non-GET requests (POST, PUT, DELETE)
  if (request.method !== 'GET') {
    return;
  }
  
  event.respondWith(
    handleRequest(request)
  );
});

// ‚≠ê Smart Request Handler
async function handleRequest(request) {
  const url = new URL(request.url);
  
  try {
    // 1. Static resources - Cache First
    if (isStaticResource(url.pathname)) {
      return await cacheFirst(request, STATIC_CACHE);
    }
    
    // 2. API calls - Network First with fallback
    if (url.pathname.startsWith('/api/')) {
      return await networkFirstWithFallback(request);
    }
    
    // 3. HTML pages - Network First
    if (url.pathname.endsWith('.html') || url.pathname === '/') {
      return await networkFirst(request, STATIC_CACHE);
    }
    
    // 4. Default - Network only
    return await fetch(request);
    
  } catch (error) {
    console.error('üì± Service Worker: Request failed', request.url, error);
    
    // ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö‡∏´‡∏ô‡πâ‡∏≤ offline ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    if (request.destination === 'document') {
      const offlineResponse = await caches.match('/offline.html');
      return offlineResponse || new Response('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï');
    }
    
    throw error;
  }
}

// ‚≠ê Cache First Strategy (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö static resources)
async function cacheFirst(request, cacheName) {
  const cached = await caches.match(request);
  if (cached) {
    console.log('üì± SW: Cache hit', request.url);
    return cached;
  }
  
  console.log('üì± SW: Fetching and caching', request.url);
  const response = await fetch(request);
  
  if (response.ok) {
    const cache = await caches.open(cacheName);
    cache.put(request, response.clone());
  }
  
  return response;
}

// ‚≠ê Network First Strategy (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API calls)
async function networkFirst(request, cacheName) {
  try {
    const response = await fetch(request);
    
    if (response.ok && cacheName) {
      const cache = await caches.open(cacheName);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.log('üì± SW: Network failed, checking cache', request.url);
    const cached = await caches.match(request);
    if (cached) {
      return cached;
    }
    throw error;
  }
}

// ‚≠ê Network First with Smart Fallback (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API)
async function networkFirstWithFallback(request) {
  const url = new URL(request.url);
  
  try {
    // ‡∏•‡∏≠‡∏á network ‡∏Å‡πà‡∏≠‡∏ô
    const response = await fetch(request);
    
    if (response.ok) {
      // Cache API responses ‡∏ó‡∏µ‡πà cache ‡πÑ‡∏î‡πâ
      if (isCacheableAPI(url.pathname)) {
        const cache = await caches.open(API_CACHE);
        cache.put(request, response.clone());
      }
      return response;
    }
    
    throw new Error(`HTTP ${response.status}`);
    
  } catch (error) {
    console.log('üì± SW: API network failed', request.url, error.message);
    
    // ‡∏•‡∏≠‡∏á cache ‡∏ñ‡πâ‡∏≤ network ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß
    const cached = await caches.match(request);
    if (cached) {
      console.log('üì± SW: Serving cached API response', request.url);
      
      // ‡πÄ‡∏û‡∏¥‡πà‡∏° header ‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡∏°‡∏≤‡∏à‡∏≤‡∏Å cache
      const headers = new Headers(cached.headers);
      headers.set('X-Served-By', 'ServiceWorker');
      headers.set('X-Cache-Date', cached.headers.get('date') || 'unknown');
      
      return new Response(cached.body, {
        status: cached.status,
        statusText: cached.statusText,
        headers: headers
      });
    }
    
    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ cache ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏Å‡∏•‡∏±‡∏ö offline response
    return createOfflineAPIResponse(url.pathname);
  }
}

// ‚≠ê Helper Functions
function isStaticResource(pathname) {
  const staticExtensions = ['.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', '.woff', '.woff2'];
  return staticExtensions.some(ext => pathname.endsWith(ext)) || 
         pathname === '/' || 
         pathname.endsWith('.html');
}

function isCacheableAPI(pathname) {
  return CACHEABLE_APIS.some(api => pathname.startsWith(api));
}

function createOfflineAPIResponse(pathname) {
  let offlineData = { success: false, msg: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï' };
  
  // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• mock ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö API ‡∏ö‡∏≤‡∏á‡∏ï‡∏±‡∏ß
  if (pathname.includes('/employees')) {
    offlineData = {
      success: false,
      msg: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï',
      offline: true,
      employees: [] // ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡πà‡∏≤‡∏á
    };
  } else if (pathname.includes('/dashboard')) {
    offlineData = {
      success: false,
      msg: '‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï',
      offline: true,
      today: {
        total_employees: 0,
        checked_in: 0,
        not_checked_out: 0,
        date: new Date().toLocaleDateString('th-TH')
      }
    };
  } else if (pathname.includes('/getLiffId')) {
    offlineData = {
      success: true,
      liffId: '2001032478-VR5Akj0k'
    };
  }
  
  return new Response(JSON.stringify(offlineData), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
      'X-Served-By': 'ServiceWorker-Offline'
    }
  });
}

// ‚≠ê Background Sync ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö offline actions
self.addEventListener('sync', event => {
  console.log('üì± SW: Background sync triggered', event.tag);
  
  if (event.tag === 'clock-in-sync') {
    event.waitUntil(syncClockInData());
  } else if (event.tag === 'clock-out-sync') {
    event.waitUntil(syncClockOutData());
  }
});

// ‚≠ê Sync offline clock-in data
async function syncClockInData() {
  try {
    const db = await openIndexedDB();
    const pendingClockIns = await getStoredData(db, 'pendingClockIns');
    
    for (const clockInData of pendingClockIns) {
      try {
        const response = await fetch('/api/clockin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(clockInData.data)
        });
        
        if (response.ok) {
          await removeStoredData(db, 'pendingClockIns', clockInData.id);
          console.log('üì± SW: Synced clock-in data', clockInData.id);
          
          // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô user
          showNotification('‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå‡πÅ‡∏•‡πâ‡∏ß');
        }
      } catch (error) {
        console.error('üì± SW: Failed to sync clock-in', clockInData.id, error);
      }
    }
  } catch (error) {
    console.error('üì± SW: Background sync failed', error);
  }
}

// ‚≠ê Sync offline clock-out data
async function syncClockOutData() {
  try {
    const db = await openIndexedDB();
    const pendingClockOuts = await getStoredData(db, 'pendingClockOuts');
    
    for (const clockOutData of pendingClockOuts) {
      try {
        const response = await fetch('/api/clockout', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(clockOutData.data)
        });
        
        if (response.ok) {
          await removeStoredData(db, 'pendingClockOuts', clockOutData.id);
          console.log('üì± SW: Synced clock-out data', clockOutData.id);
          
          // ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô user
          showNotification('‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡∏≠‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à', '‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ñ‡∏π‡∏Å‡∏™‡πà‡∏á‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå‡πÅ‡∏•‡πâ‡∏ß');
        }
      } catch (error) {
        console.error('üì± SW: Failed to sync clock-out', clockOutData.id, error);
      }
    }
  } catch (error) {
    console.error('üì± SW: Background sync failed', error);
  }
}

// ‚≠ê Push Notification Handler
self.addEventListener('push', event => {
  console.log('üì± SW: Push notification received');
  
  const options = {
    body: '‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÉ‡∏´‡∏°‡πà',
    icon: '/icons/icon-192.png',
    badge: '/icons/badge-72.png',
    vibrate: [200, 100, 200],
    data: {
      url: '/'
    }
  };
  
  if (event.data) {
    const data = event.data.json();
    options.body = data.message || options.body;
    options.data = data;
  }
  
  event.waitUntil(
    self.registration.showNotification('‡∏£‡∏∞‡∏ö‡∏ö‡∏•‡∏á‡πÄ‡∏ß‡∏•‡∏≤', options)
  );
});

// ‚≠ê Notification Click Handler
self.addEventListener('notificationclick', event => {
  console.log('üì± SW: Notification clicked');
  event.notification.close();
  
  const url = event.notification.data?.url || '/';
  
  event.waitUntil(
    clients.openWindow(url)
  );
});

// ‚≠ê Message Handler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö communication ‡∏Å‡∏±‡∏ö main thread
self.addEventListener('message', event => {
  console.log('üì± SW: Message received', event.data);
  
  if (event.data && event.data.type === 'PERFORMANCE_REPORT') {
    console.log('üì± SW: Performance report received', event.data.metrics);
    
    // Store performance data
    storePerformanceData(event.data.metrics);
    
    // Send to analytics if needed
    // sendToAnalytics(event.data.metrics);
  } else if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  } else if (event.data && event.data.type === 'CACHE_CLEAR') {
    clearAllCaches();
  }
});

// ‚≠ê IndexedDB Helper Functions
async function openIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('TimeTrackerDB', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      if (!db.objectStoreNames.contains('pendingClockIns')) {
        db.createObjectStore('pendingClockIns', { keyPath: 'id', autoIncrement: true });
      }
      
      if (!db.objectStoreNames.contains('pendingClockOuts')) {
        db.createObjectStore('pendingClockOuts', { keyPath: 'id', autoIncrement: true });
      }
      
      if (!db.objectStoreNames.contains('performanceData')) {
        db.createObjectStore('performanceData', { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

async function getStoredData(db, storeName) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.getAll();
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

async function removeStoredData(db, storeName, id) {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

async function storePerformanceData(data) {
  try {
    const db = await openIndexedDB();
    const transaction = db.transaction(['performanceData'], 'readwrite');
    const store = transaction.objectStore('performanceData');
    
    await store.add({
      data: data,
      timestamp: Date.now()
    });
    
    console.log('üì± SW: Performance data stored');
  } catch (error) {
    console.error('üì± SW: Failed to store performance data', error);
  }
}

function showNotification(title, body) {
  if (self.registration.showNotification) {
    self.registration.showNotification(title, {
      body,
      icon: '/icons/icon-192.png',
      badge: '/icons/badge-72.png',
      vibrate: [200, 100, 200]
    });
  }
}

async function clearAllCaches() {
  try {
    const cacheNames = await caches.keys();
    await Promise.all(cacheNames.map(name => caches.delete(name)));
    console.log('üì± SW: All caches cleared');
  } catch (error) {
    console.error('üì± SW: Failed to clear caches', error);
  }
}

// ‚≠ê Periodic Background Sync
self.addEventListener('periodicsync', event => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync());
  }
});

async function doBackgroundSync() {
  console.log('üì± SW: Periodic background sync');
  
  try {
    // Sync offline data
    await syncClockInData();
    await syncClockOutData();
    
    // Clean old cache entries
    await cleanOldCacheEntries();
    
    console.log('üì± SW: Background sync completed');
  } catch (error) {
    console.error('üì± SW: Background sync failed', error);
  }
}

async function cleanOldCacheEntries() {
  try {
    const cache = await caches.open(API_CACHE);
    const requests = await cache.keys();
    
    // Remove cache entries older than 1 hour
    const oneHourAgo = Date.now() - (60 * 60 * 1000);
    
    for (const request of requests) {
      const response = await cache.match(request);
      const dateHeader = response.headers.get('date');
      
      if (dateHeader) {
        const responseDate = new Date(dateHeader).getTime();
        if (responseDate < oneHourAgo) {
          await cache.delete(request);
          console.log('üì± SW: Removed old cache entry', request.url);
        }
      }
    }
  } catch (error) {
    console.error('üì± SW: Failed to clean old cache entries', error);
  }
}

// ‚≠ê Error Handler
self.addEventListener('error', event => {
  console.error('üì± SW: Service Worker error', event.error);
});

self.addEventListener('unhandledrejection', event => {
  console.error('üì± SW: Unhandled promise rejection', event.reason);
});

console.log('üì± Service Worker: Script loaded successfully');